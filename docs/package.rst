Package Organization and Functionality
======================================
This section covers a broad overview of the package, for a more detailed description see the sections in the full :ref:`api_docs`.
The package is created using the de facto numerical and scientific computing libraries for python, Numpy_ and Scipy_.
There are three major parts to the toolbox: models, algorithms, and visualization.


Models
------
The primary responsibility of the models component is to provide means for easy handling of virtual ultrasonic transducer arrays and their elements.
This is the foundation on which the other parts build, with methods to calculate sound fields from arbitrary arrays arrangements.
This part of the package in class-oriented, organized in two python modules.
The ``arrays`` module with the primary class ``TransducerArray`` handles collections of individual transducer elements, i.e. arrays, operating all elements as a whole.
The ``transducers`` module with the primary class ``TransducerModel`` handles single transducers and their radiation characteristics.


Algorithms
----------
The algorithms component of the package collects the sound field design methods under a unified framework.
The current implementation covers optimization of transducer array amplitudes and phases according to a set of cost functions.
All the cost functions have a physical interpretation such as the force on a small bead of a specific size, or the sound pressure at a certain point.


Visualization
-------------
Visualization of data is a complicated topic, and visualization in python in particular comes in many flavors.
For the purposes of this toolbox, the main concern is to quickly verify that the design algorithms deliver the intended result.
To this end, a small set of tools are implemented using the Plotly_ graphing library, which has good support for interactive visualizations.
The current implementation is focused on providing representations of the sound field generated by an array.

Workflow
--------
Designing a sound field for a specific application involves choosing appropriate combinations of cost functions and optimization routines.
A typical workflow from application specification to result is:

1) Specify what the sound field should do; *Levitate a bead.*
2) Find the appropriate mathematical formulation and choose the equivalent cost functions; *Maximize the Gor'kov Laplacian and minimize the sound pressure*
3) Choose an optimization routine; *minimization with fixed amplitudes*
4) Run the optimization.
5) Visualize the resulting sound field.
6) Export the result to use with a physical array.

For more detailed descriptions of workflows, refer to the :ref:`examples`.

.. _Numpy: http://www.numpy.org
.. _Scipy: http://www.scipy.org
.. _Plotly: https://plot.ly/python/
